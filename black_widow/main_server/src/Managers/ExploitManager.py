from Managers.FileManager import FileManager
from Managers.DatabaseManager import DatabaseManager
from Entities.Response import Response
from Entities.Exploit import Exploit

class ExploitManager():

    def __init__(self, db_manager = DatabaseManager()):
        self.file_manager = FileManager()
        self.db_manager = db_manager
        self.exploits_dict = self._initializeFromDatabase()

    def _initializeFromDatabase(self):
        # Variables
        exploits_dict = dict()
        exploits = self.db_manager.getExploits()
        for raw_exploit in exploits:
            del raw_exploit["_id"]
            exploit_name = raw_exploit["name"]
            exploit = Exploit().objectFromDictionary(raw_exploit)
            exploits_dict[exploit_name] = exploit
        return exploits_dict

    def newEmpty(self, exploit_name):
        """
        Creates a new exploit which includes the folders and the exploit JSON file
        :param exploit_name: String with the exploit name
        :return: True if the new exploit was successfully created
        """
        response = Response()
        if exploit_name not in self.exploits_dict:
            exploit = Exploit(exploit_name)
            self.exploits_dict[exploit_name] = exploit
            self.db_manager.insertExploit(exploit.dictionary().copy())
            response.setResponse(True)
            response.setBody(exploit.dictionary())
        else:
            response.setResponse(False)
            response.setReason('Exploit already exist')
            response.setBody(dict())
        return response.dictionary()

    def getAll(self):
        """
        Gets the available exploits
        :return: A list of strings with the available scenarios
        """
        # Variables
        exploits_dict = {"exploits": [self.exploits_dict[e].name for e in self.exploits_dict]}
        response = Response()
        response.setResponse(True)
        response.setBody(exploits_dict)
        return response.dictionary()


    def getOne(self, exploit_name):
        """
        Gets the scenario as a JSON file
        :param exploit_name: String with the scenario name
        :return: JSON file with the scenario info
        """
        response = Response()
        if exploit_name in self.exploits_dict:
            response.setResponse(True)
            response.setBody(self.exploits_dict[exploit_name].dictionary())
        else:
            response.setResponse(False)
            response.setReason('Exploit doesn\'t exist')
            response.setBody(dict())
        return response.dictionary()

    def editOne(self, exploit_json):
        """
        Edits a current scenario with a JSON file
        :param exploit_name: String with the scenario name
        :param scenario_json: JSON file with the new scenario
        :return: True if the scenario has been successfully edited, otherwise False
        """
        response = Response()
        print(exploit_json)
        exploit_name = exploit_json["name"]
        if exploit_name in self.exploits_dict:
            exploit_json = Exploit().objectFromDictionary(exploit_json)
            self.exploits_dict[exploit_name] = exploit_json
            self.db_manager.editExploit(exploit_json.dictionary().copy())
            response.setResponse(True)
            response.setBody(self.exploits_dict[exploit_name].dictionary())
        else:
            response.setReason('Exploit doesn\'t exist')
            response.setResponse(False)
            response.setBody(dict())
        return response.dictionary()

    def deleteOne(self, exploit_name):
        response = Response()
        if exploit_name in self.exploits_dict:
            deleted_exploit = self.exploits_dict.pop(exploit_name)
            self.db_manager.deleteExploit(exploit_name)
            response.setResponse(True)
            response.setBody(deleted_exploit.dictionary())
        else:
            response.setResponse(False)
            response.setReason('Exploit doesn\'t exist')
            response.setBody(dict())
        return response.dictionary()
